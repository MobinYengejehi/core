// Code generated by "core generate"; DO NOT EDIT.

package textcore

import (
	"image"
	"io"
	"time"

	"github.com/MobinYengejehi/core/core"
	"github.com/MobinYengejehi/core/styles/units"
	"github.com/MobinYengejehi/core/text/lines"
	"github.com/MobinYengejehi/core/text/rich"
	"github.com/MobinYengejehi/core/tree"
	"github.com/MobinYengejehi/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/MobinYengejehi/core/text/textcore.Base", IDName: "base", Doc: "Base is a widget with basic infrastructure for viewing and editing\n[lines.Lines] of monospaced text, used in [textcore.Editor] and\nterminal. There can be multiple Base widgets for each lines buffer.\n\nUse NeedsRender to drive an render update for any change that does\nnot change the line-level layout of the text.\n\nAll updating in the Base should be within a single goroutine,\nas it would require extensive protections throughout code otherwise.", Directives: []types.Directive{{Tool: "core", Directive: "embedder"}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Lines", Doc: "Lines is the text lines content for this editor."}, {Name: "CursorWidth", Doc: "CursorWidth is the width of the cursor.\nThis should be set in Stylers like all other style properties."}, {Name: "LineNumberColor", Doc: "LineNumberColor is the color used for the side bar containing the line numbers.\nThis should be set in Stylers like all other style properties."}, {Name: "SelectColor", Doc: "SelectColor is the color used for the user text selection background color.\nThis should be set in Stylers like all other style properties."}, {Name: "HighlightColor", Doc: "HighlightColor is the color used for the text highlight background color (like in find).\nThis should be set in Stylers like all other style properties."}, {Name: "CursorColor", Doc: "CursorColor is the color used for the text editor cursor bar.\nThis should be set in Stylers like all other style properties."}, {Name: "AutoscrollOnInput", Doc: "AutoscrollOnInput scrolls the display to the end when Input events are received."}, {Name: "viewId", Doc: "viewId is the unique id of the Lines view."}, {Name: "charSize", Doc: "charSize is the render size of one character (rune).\nY = line height, X = total glyph advance."}, {Name: "visSizeAlloc", Doc: "visSizeAlloc is the Geom.Size.Alloc.Total subtracting extra space,\navailable for rendering text lines and line numbers."}, {Name: "lastVisSizeAlloc", Doc: "lastVisSizeAlloc is the last visSizeAlloc used in laying out lines.\nIt is used to trigger a new layout only when needed."}, {Name: "visSize", Doc: "visSize is the height in lines and width in chars of the visible area."}, {Name: "linesSize", Doc: "linesSize is the height in lines and width in chars of the Lines text area,\n(excluding line numbers), which can be larger than the visSize."}, {Name: "scrollPos", Doc: "scrollPos is the position of the scrollbar, in units of lines of text.\nfractional scrolling is supported."}, {Name: "hasLineNumbers", Doc: "hasLineNumbers indicates that this editor has line numbers\n(per [Editor] option)"}, {Name: "lineNumberOffset", Doc: "lineNumberOffset is the horizontal offset in chars for the start of text\nafter line numbers. This is 0 if no line numbers."}, {Name: "totalSize", Doc: "totalSize is total size of all text, including line numbers,\nmultiplied by charSize."}, {Name: "lineNumberDigits", Doc: "lineNumberDigits is the number of line number digits needed."}, {Name: "CursorPos", Doc: "CursorPos is the current cursor position."}, {Name: "blinkOn", Doc: "blinkOn oscillates between on and off for blinking."}, {Name: "cursorMu", Doc: "cursorMu is a mutex protecting cursor rendering, shared between blink and main code."}, {Name: "isScrolling", Doc: "isScrolling is true when scrolling: prevents keeping current cursor position\nin view."}, {Name: "cursorTarget", Doc: "cursorTarget is the target cursor position for externally set targets.\nIt ensures that the target position is visible."}, {Name: "cursorColumn", Doc: "cursorColumn is the desired cursor column, where the cursor was\nlast when moved using left / right arrows.\nIt is used when doing up / down to not always go to short line columns."}, {Name: "posHistoryIndex", Doc: "posHistoryIndex is the current index within PosHistory."}, {Name: "selectStart", Doc: "selectStart is the starting point for selection, which will either\nbe the start or end of selected region depending on subsequent selection."}, {Name: "SelectRegion", Doc: "SelectRegion is the current selection region."}, {Name: "previousSelectRegion", Doc: "previousSelectRegion is the previous selection region that was actually rendered.\nIt is needed to update the render."}, {Name: "Highlights", Doc: "Highlights is a slice of regions representing the highlighted\nregions, e.g., for search results."}, {Name: "scopelights", Doc: "scopelights is a slice of regions representing the highlighted\nregions specific to scope markers."}, {Name: "LinkHandler", Doc: "LinkHandler handles link clicks.\nIf it is nil, they are sent to the standard web URL handler."}, {Name: "lineRenders", Doc: "lineRenders are the cached rendered lines of text."}, {Name: "lineNoRenders", Doc: "lineNoRenders are the cached rendered line numbers"}, {Name: "tabRender", Doc: "tabRender is a shaped tab"}, {Name: "selectMode", Doc: "selectMode is a boolean indicating whether to select text as the cursor moves."}, {Name: "lastWasTabAI", Doc: "lastWasTabAI indicates that last key was a Tab auto-indent"}, {Name: "lastWasUndo", Doc: "lastWasUndo indicates that last key was an undo"}, {Name: "targetSet", Doc: "targetSet indicates that the CursorTarget is set"}, {Name: "lastRecenter"}, {Name: "lastAutoInsert"}, {Name: "lastFilename"}}})

// NewBase returns a new [Base] with the given optional parent:
// Base is a widget with basic infrastructure for viewing and editing
// [lines.Lines] of monospaced text, used in [textcore.Editor] and
// terminal. There can be multiple Base widgets for each lines buffer.
//
// Use NeedsRender to drive an render update for any change that does
// not change the line-level layout of the text.
//
// All updating in the Base should be within a single goroutine,
// as it would require extensive protections throughout code otherwise.
func NewBase(parent ...tree.Node) *Base { return tree.New[Base](parent...) }

// BaseEmbedder is an interface that all types that embed Base satisfy
type BaseEmbedder interface {
	AsBase() *Base
}

// AsBase returns the given value as a value of type Base if the type
// of the given value embeds Base, or nil otherwise
func AsBase(n tree.Node) *Base {
	if t, ok := n.(BaseEmbedder); ok {
		return t.AsBase()
	}
	return nil
}

// AsBase satisfies the [BaseEmbedder] interface
func (t *Base) AsBase() *Base { return t }

// SetCursorWidth sets the [Base.CursorWidth]:
// CursorWidth is the width of the cursor.
// This should be set in Stylers like all other style properties.
func (t *Base) SetCursorWidth(v units.Value) *Base { t.CursorWidth = v; return t }

// SetLineNumberColor sets the [Base.LineNumberColor]:
// LineNumberColor is the color used for the side bar containing the line numbers.
// This should be set in Stylers like all other style properties.
func (t *Base) SetLineNumberColor(v image.Image) *Base { t.LineNumberColor = v; return t }

// SetSelectColor sets the [Base.SelectColor]:
// SelectColor is the color used for the user text selection background color.
// This should be set in Stylers like all other style properties.
func (t *Base) SetSelectColor(v image.Image) *Base { t.SelectColor = v; return t }

// SetHighlightColor sets the [Base.HighlightColor]:
// HighlightColor is the color used for the text highlight background color (like in find).
// This should be set in Stylers like all other style properties.
func (t *Base) SetHighlightColor(v image.Image) *Base { t.HighlightColor = v; return t }

// SetCursorColor sets the [Base.CursorColor]:
// CursorColor is the color used for the text editor cursor bar.
// This should be set in Stylers like all other style properties.
func (t *Base) SetCursorColor(v image.Image) *Base { t.CursorColor = v; return t }

// SetAutoscrollOnInput sets the [Base.AutoscrollOnInput]:
// AutoscrollOnInput scrolls the display to the end when Input events are received.
func (t *Base) SetAutoscrollOnInput(v bool) *Base { t.AutoscrollOnInput = v; return t }

// SetLinkHandler sets the [Base.LinkHandler]:
// LinkHandler handles link clicks.
// If it is nil, they are sent to the standard web URL handler.
func (t *Base) SetLinkHandler(v func(tl *rich.Hyperlink)) *Base { t.LinkHandler = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/MobinYengejehi/core/text/textcore.DiffEditor", IDName: "diff-editor", Doc: "DiffEditor presents two side-by-side [Editor]s showing the differences\nbetween two files (represented as lines of strings).", Methods: []types.Method{{Name: "saveFileA", Doc: "saveFileA saves the current state of file A to given filename", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fname"}}, {Name: "saveFileB", Doc: "saveFileB saves the current state of file B to given filename", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fname"}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "FileA", Doc: "first file name being compared"}, {Name: "FileB", Doc: "second file name being compared"}, {Name: "RevisionA", Doc: "revision for first file, if relevant"}, {Name: "RevisionB", Doc: "revision for second file, if relevant"}, {Name: "linesA", Doc: "[lines.Lines] for A showing the aligned edit view"}, {Name: "linesB", Doc: "[lines.Lines] for B showing the aligned edit view"}, {Name: "alignD", Doc: "aligned diffs records diff for aligned lines"}, {Name: "diffs", Doc: "diffs applied"}, {Name: "inInputEvent"}, {Name: "toolbar"}}})

// NewDiffEditor returns a new [DiffEditor] with the given optional parent:
// DiffEditor presents two side-by-side [Editor]s showing the differences
// between two files (represented as lines of strings).
func NewDiffEditor(parent ...tree.Node) *DiffEditor { return tree.New[DiffEditor](parent...) }

// SetFileA sets the [DiffEditor.FileA]:
// first file name being compared
func (t *DiffEditor) SetFileA(v string) *DiffEditor { t.FileA = v; return t }

// SetFileB sets the [DiffEditor.FileB]:
// second file name being compared
func (t *DiffEditor) SetFileB(v string) *DiffEditor { t.FileB = v; return t }

// SetRevisionA sets the [DiffEditor.RevisionA]:
// revision for first file, if relevant
func (t *DiffEditor) SetRevisionA(v string) *DiffEditor { t.RevisionA = v; return t }

// SetRevisionB sets the [DiffEditor.RevisionB]:
// revision for second file, if relevant
func (t *DiffEditor) SetRevisionB(v string) *DiffEditor { t.RevisionB = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/MobinYengejehi/core/text/textcore.DiffTextEditor", IDName: "diff-text-editor", Doc: "DiffTextEditor supports double-click based application of edits from one\nlines to the other.", Embeds: []types.Field{{Name: "Editor"}}})

// NewDiffTextEditor returns a new [DiffTextEditor] with the given optional parent:
// DiffTextEditor supports double-click based application of edits from one
// lines to the other.
func NewDiffTextEditor(parent ...tree.Node) *DiffTextEditor {
	return tree.New[DiffTextEditor](parent...)
}

var _ = types.AddType(&types.Type{Name: "github.com/MobinYengejehi/core/text/textcore.Editor", IDName: "editor", Doc: "Editor is a widget for editing multiple lines of complicated text (as compared to\n[core.TextField] for a single line of simple text).  The Editor is driven by a\n[lines.Lines] buffer which contains all the text, and manages all the edits,\nsending update events out to the editors.\n\nUse NeedsRender to drive an render update for any change that does\nnot change the line-level layout of the text.\n\nMultiple editors can be attached to a given buffer.  All updating in the\nEditor should be within a single goroutine, as it would require\nextensive protections throughout code otherwise.", Directives: []types.Directive{{Tool: "core", Directive: "embedder"}}, Methods: []types.Method{{Name: "Lookup", Doc: "Lookup attempts to lookup symbol at current location, popping up a window\nif something is found.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "SaveAs", Doc: "SaveAs saves the current text into given file; does an editDone first to save edits\nand checks for an existing file; if it does exist then prompts to overwrite or not.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}}, {Name: "Save", Doc: "Save saves the current text into the current filename associated with this buffer.\nDo NOT use this in an OnChange event handler as it emits a Change event! Use\n[Editor.SaveQuiet] instead.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"error"}}, {Name: "SaveQuiet", Doc: "SaveQuiet saves the current text into the current filename associated with this buffer.\nThis version does not emit a change event, so it is safe to use\nin an OnChange event handler, unlike [Editor.Save].", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"error"}}}, Embeds: []types.Field{{Name: "Base"}}, Fields: []types.Field{{Name: "ISearch", Doc: "ISearch is the interactive search data."}, {Name: "QReplace", Doc: "QReplace is the query replace data."}, {Name: "Complete", Doc: "Complete is the functions and data for text completion."}, {Name: "spell", Doc: "spell is the functions and data for spelling correction."}, {Name: "curFilename", Doc: "curFilename is the current filename from Lines. Used to detect changed file."}}})

// NewEditor returns a new [Editor] with the given optional parent:
// Editor is a widget for editing multiple lines of complicated text (as compared to
// [core.TextField] for a single line of simple text).  The Editor is driven by a
// [lines.Lines] buffer which contains all the text, and manages all the edits,
// sending update events out to the editors.
//
// Use NeedsRender to drive an render update for any change that does
// not change the line-level layout of the text.
//
// Multiple editors can be attached to a given buffer.  All updating in the
// Editor should be within a single goroutine, as it would require
// extensive protections throughout code otherwise.
func NewEditor(parent ...tree.Node) *Editor { return tree.New[Editor](parent...) }

// EditorEmbedder is an interface that all types that embed Editor satisfy
type EditorEmbedder interface {
	AsEditor() *Editor
}

// AsEditor returns the given value as a value of type Editor if the type
// of the given value embeds Editor, or nil otherwise
func AsEditor(n tree.Node) *Editor {
	if t, ok := n.(EditorEmbedder); ok {
		return t.AsEditor()
	}
	return nil
}

// AsEditor satisfies the [EditorEmbedder] interface
func (t *Editor) AsEditor() *Editor { return t }

// SetComplete sets the [Editor.Complete]:
// Complete is the functions and data for text completion.
func (t *Editor) SetComplete(v *core.Complete) *Editor { t.Complete = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/MobinYengejehi/core/text/textcore.OutputBuffer", IDName: "output-buffer", Doc: "OutputBuffer is a buffer that records the output from an [io.Reader] using\n[bufio.Scanner]. It is optimized to combine fast chunks of output into\nlarge blocks of updating. It also supports an arbitrary markup function\nthat operates on each line of output text.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "Mutex", Doc: "mutex protecting updates"}}, Fields: []types.Field{{Name: "Output", Doc: "the output that we are reading from, as an io.Reader"}, {Name: "Lines", Doc: "the [lines.Lines] that we output to"}, {Name: "Batch", Doc: "how much time to wait while batching output (default: 200ms)"}, {Name: "MarkupFunc", Doc: "MarkupFunc is an optional markup function that adds html tags to given line\nof output. It is essential that it not add any new text, just splits into spans\nwith different styles."}, {Name: "bufferedLines", Doc: "current buffered output raw lines, which are not yet sent to the Buffer"}, {Name: "bufferedMarkup", Doc: "current buffered output markup lines, which are not yet sent to the Buffer"}, {Name: "lastOutput", Doc: "time when last output was sent to buffer"}, {Name: "afterTimer", Doc: "time.AfterFunc that is started after new input is received and not\nimmediately output. Ensures that it will get output if no further burst happens."}}})

// SetOutput sets the [OutputBuffer.Output]:
// the output that we are reading from, as an io.Reader
func (t *OutputBuffer) SetOutput(v io.Reader) *OutputBuffer { t.Output = v; return t }

// SetLines sets the [OutputBuffer.Lines]:
// the [lines.Lines] that we output to
func (t *OutputBuffer) SetLines(v *lines.Lines) *OutputBuffer { t.Lines = v; return t }

// SetBatch sets the [OutputBuffer.Batch]:
// how much time to wait while batching output (default: 200ms)
func (t *OutputBuffer) SetBatch(v time.Duration) *OutputBuffer { t.Batch = v; return t }

// SetMarkupFunc sets the [OutputBuffer.MarkupFunc]:
// MarkupFunc is an optional markup function that adds html tags to given line
// of output. It is essential that it not add any new text, just splits into spans
// with different styles.
func (t *OutputBuffer) SetMarkupFunc(v OutputBufferMarkupFunc) *OutputBuffer {
	t.MarkupFunc = v
	return t
}

var _ = types.AddType(&types.Type{Name: "github.com/MobinYengejehi/core/text/textcore.TwinEditors", IDName: "twin-editors", Doc: "TwinEditors presents two side-by-side [Editor]s in [core.Splits]\nthat scroll in sync with each other.", Embeds: []types.Field{{Name: "Splits"}}, Fields: []types.Field{{Name: "BufferA", Doc: "[Buffer] for A"}, {Name: "BufferB", Doc: "[Buffer] for B"}, {Name: "inInputEvent"}}})

// NewTwinEditors returns a new [TwinEditors] with the given optional parent:
// TwinEditors presents two side-by-side [Editor]s in [core.Splits]
// that scroll in sync with each other.
func NewTwinEditors(parent ...tree.Node) *TwinEditors { return tree.New[TwinEditors](parent...) }

// SetBufferA sets the [TwinEditors.BufferA]:
// [Buffer] for A
func (t *TwinEditors) SetBufferA(v *lines.Lines) *TwinEditors { t.BufferA = v; return t }

// SetBufferB sets the [TwinEditors.BufferB]:
// [Buffer] for B
func (t *TwinEditors) SetBufferB(v *lines.Lines) *TwinEditors { t.BufferB = v; return t }
