// Code generated by "core generate"; DO NOT EDIT.

package text

import (
	"github.com/MobinYengejehi/core/enums"
)

var _AlignsValues = []Aligns{0, 1, 2, 3}

// AlignsN is the highest valid value for type Aligns, plus one.
const AlignsN Aligns = 4

var _AlignsValueMap = map[string]Aligns{`start`: 0, `end`: 1, `center`: 2, `justify`: 3}

var _AlignsDescMap = map[Aligns]string{0: `Start aligns to the start (top, left) of text region.`, 1: `End aligns to the end (bottom, right) of text region.`, 2: `Center aligns to the center of text region.`, 3: `Justify spreads words to cover the entire text region.`}

var _AlignsMap = map[Aligns]string{0: `start`, 1: `end`, 2: `center`, 3: `justify`}

// String returns the string representation of this Aligns value.
func (i Aligns) String() string { return enums.String(i, _AlignsMap) }

// SetString sets the Aligns value from its string representation,
// and returns an error if the string is invalid.
func (i *Aligns) SetString(s string) error { return enums.SetString(i, s, _AlignsValueMap, "Aligns") }

// Int64 returns the Aligns value as an int64.
func (i Aligns) Int64() int64 { return int64(i) }

// SetInt64 sets the Aligns value from an int64.
func (i *Aligns) SetInt64(in int64) { *i = Aligns(in) }

// Desc returns the description of the Aligns value.
func (i Aligns) Desc() string { return enums.Desc(i, _AlignsDescMap) }

// AlignsValues returns all possible values for the type Aligns.
func AlignsValues() []Aligns { return _AlignsValues }

// Values returns all possible values for the type Aligns.
func (i Aligns) Values() []enums.Enum { return enums.Values(_AlignsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Aligns) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Aligns) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Aligns") }

var _WhiteSpacesValues = []WhiteSpaces{0, 1, 2, 3, 4, 5}

// WhiteSpacesN is the highest valid value for type WhiteSpaces, plus one.
const WhiteSpacesN WhiteSpaces = 6

var _WhiteSpacesValueMap = map[string]WhiteSpaces{`WrapAsNeeded`: 0, `WrapAlways`: 1, `WrapSpaceOnly`: 2, `WrapNever`: 3, `Pre`: 4, `PreWrap`: 5}

var _WhiteSpacesDescMap = map[WhiteSpaces]string{0: `WrapAsNeeded means that all white space is collapsed to a single space, and text wraps at white space except if there is a long word that cannot fit on the next line, or would otherwise be truncated. To get full word wrapping to expand to all available space, you also need to set GrowWrap = true. Use the SetTextWrap convenience method to set both.`, 1: `WrapAlways is like [WrapAsNeeded] except that line wrap will always occur within words if it allows more content to fit on a line.`, 2: `WrapSpaceOnly means that line wrapping only occurs at white space, and never within words. This means that long words may then exceed the available space and will be truncated. White space is collapsed to a single space.`, 3: `WrapNever means that lines are never wrapped to fit. If there is an explicit line or paragraph break, that will still result in a new line. In general you also don&#39;t want simple non-wrapping text labels to Grow (GrowWrap = false). Use the SetTextWrap method to set both. White space is collapsed to a single space.`, 4: `WhiteSpacePre means that whitespace is preserved, including line breaks. Text will only wrap on explicit line or paragraph breaks. This acts like the &lt;pre&gt; tag in HTML.`, 5: `WhiteSpacePreWrap means that whitespace is preserved. Text will wrap when necessary, and on line breaks`}

var _WhiteSpacesMap = map[WhiteSpaces]string{0: `WrapAsNeeded`, 1: `WrapAlways`, 2: `WrapSpaceOnly`, 3: `WrapNever`, 4: `Pre`, 5: `PreWrap`}

// String returns the string representation of this WhiteSpaces value.
func (i WhiteSpaces) String() string { return enums.String(i, _WhiteSpacesMap) }

// SetString sets the WhiteSpaces value from its string representation,
// and returns an error if the string is invalid.
func (i *WhiteSpaces) SetString(s string) error {
	return enums.SetString(i, s, _WhiteSpacesValueMap, "WhiteSpaces")
}

// Int64 returns the WhiteSpaces value as an int64.
func (i WhiteSpaces) Int64() int64 { return int64(i) }

// SetInt64 sets the WhiteSpaces value from an int64.
func (i *WhiteSpaces) SetInt64(in int64) { *i = WhiteSpaces(in) }

// Desc returns the description of the WhiteSpaces value.
func (i WhiteSpaces) Desc() string { return enums.Desc(i, _WhiteSpacesDescMap) }

// WhiteSpacesValues returns all possible values for the type WhiteSpaces.
func WhiteSpacesValues() []WhiteSpaces { return _WhiteSpacesValues }

// Values returns all possible values for the type WhiteSpaces.
func (i WhiteSpaces) Values() []enums.Enum { return enums.Values(_WhiteSpacesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i WhiteSpaces) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *WhiteSpaces) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "WhiteSpaces")
}
